# FILE I/O BUFFER

## Kernel Buffering
`read()` and `write()` system calls simply copy data between a user-space buffer and a buffer in the kernel *kernel cache*.

The kernel imposes no fixed upper limit on the size of the buffer cache.

### Effect of buffer size on I/O system call performance
The impact of performing file I/O using different buffer sizes can be seen by running the program with different *BUF_SIZE* values.

> When we talk about a vanilla kernel, we mean an unpatched mainline kernel.


## Buffering in the *stdio* Library
### Setting the buffering mode of a *stdio* stream
The `setvbuf()` function controls the form of buffering employed by the *stdio* library.
```c
#include <stdio.h>

int setvbuf(FILE *stream, char *buf, int mode, size_t size);
// Returns 0 on success, or nonzero on error
```
> After the stream has been opened, the `setvbuf()` call must be made before calling any other `stdio` function on the stream.

The *buf* and *size* arguments specify the buffer to be used for stream. These arguments may be specified in two ways:
- If the *buf* is non-NULL, then it points to a block of memory of *size* bytes that is to be used as the buffer for *stream*.
- If *buf* is NULL, then the *stdio* library automatically allocates a buffer for use with *stream*.

The *mode* argument specifies the  type of buffering and has one of the following values:
- \_IONBF: Don't buffer I/O. Each *stdio* library call results in an immediate *write()* or *read()* system call.
- \_IOLBF: Employ line-buffered I/O.
- \_IOFBF: Employ fully buffered I/O.

The following code demonstrated the use of *setvbuf()*:
```c
#define BUF_SIZE 1024
static char buf[BUF_SIZE]:

if (setvbuf(stdout, buf, _IOFBF, BUF_SIZE) != 0)
	errExit("setvbuf");
```

The *setbuf()* function is layered on top of *setvbuf()*, and performs a similar task.
```c
#include <stdio.h>

void setbuf(FILE *stream, char *buf);
```
the call `setbuf(fp, buf)` is equivalent to:
`setvbuf(fp, buf, (buf != NULL) ? _IOFBF: _IONBF, BUFSIZE);`
> The `buf` argument is specified either as NULL, for no buffering, or as a pointer to a caller-allocated buffer of BUFSIZE bytes.

The *setbuffer()* function is similar to *setbuf()*, but allows the caller to specify the size of *buf*.
```c
#define _BSD_SOURCE
#include <stdio.h>

void setbuffer(FILE *stream, char *buf, size_t size);
```
The call `setbuffer(fp, buf, size)` is equivalent to the following:
`setvbuf(fp, buf, (buf != NULL) ? _IOFBF : _IONBF, size);`


### Flushing a *stdio* buffer
*fflush()* library function flushes the output buffer for the specified stream (flushed to a kernel buffer via *write()*).

```c
#include <stdio.h.>

int fflush(FILE *stream);
// Returns 0 on success, EOF on error
```
If the *stream* is NULL, *fflush()* flushes all *stdio* buffers.


## Controlling Kernel Buffering of File I/O

### Synchronized I/O data integrity and synchronized I/O file integrity
> `Synchronized I/O completion` means "an I/O operation that has either been successfully transferred or diagnosed as unsuccessful."

SUSv3 defines two different types of synchronized I/O completion:

**synchronized I/O data integrity completion**, which is related to ensuring that a file data update transfers **sufficient** information to allow a later retrieval of that data to proceed.

**synchronized I/O file integrity completion**,which is a superset of **synchronized I/O data integrity**.


### System calls for controlling kernel buffering of file I/O
The `fsync()` system call causes the buffered data and all metadata associated with the open file descriptor *fd* to be flushed to disk. Calling `fsync()`  forces the file to the **synchronized I/O file integrity**.

```c
#include <unistd.h>

int fsync();
// Returns 0 on success, or -1 on error
```

> An `fsync()` call returns only after the transfer to the disk device (or at least its cache) has completed.

The `fdatasync()` only forces the file to the **synchronized I/O data integrity completion state**.

```c
#include <unistd.h>

int fdatasync(int fd);
```

